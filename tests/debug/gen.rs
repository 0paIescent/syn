// This file is @generated by syn-internal-codegen.
// It is not intended for manual editing.

use super::{Lite, RefCast};
use std::fmt::{self, Debug};
impl Debug for Lite<syn::Abi> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Abi");
        if let Some(val) = &self.value.name {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::LitStr);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("name", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::AngleBracketedGenericArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("AngleBracketedGenericArguments");
        if let Some(val) = &self.value.colon2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon2_token", Print::ref_cast(val));
        }
        formatter.field("args", Lite(&self.value.args));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ArgCaptured> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ArgCaptured");
        formatter.field("pat", Lite(&self.value.pat));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ArgSelf> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ArgSelf");
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ArgSelfRef> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ArgSelfRef");
        if let Some(val) = &self.value.lifetime {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetime", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Arm> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Arm");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.leading_vert {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Or);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_vert", Print::ref_cast(val));
        }
        formatter.field("pats", Lite(&self.value.pats));
        if let Some(val) = &self.value.guard {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::If, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("guard", Print::ref_cast(val));
        }
        formatter.field("body", Lite(&self.value.body));
        if let Some(val) = &self.value.comma {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Comma);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("comma", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::AttrStyle> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::AttrStyle::Outer => formatter.write_str("Outer"),
            syn::AttrStyle::Inner(_v0) => {
                let mut formatter = formatter.debug_tuple("Inner");
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Attribute> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Attribute");
        formatter.field("style", Lite(&self.value.style));
        formatter.field("path", Lite(&self.value.path));
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::BareFnArg> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("BareFnArg");
        if let Some(val) = &self.value.name {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::BareFnArgName, syn::token::Colon));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.0), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("name", Print::ref_cast(val));
        }
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::BareFnArgName> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::BareFnArgName::Named(_v0) => {
                let mut formatter = formatter.debug_tuple("Named");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::BareFnArgName::Wild(_v0) => {
                let mut formatter = formatter.debug_tuple("Wild");
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::BinOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::BinOp::Add(_v0) => {
                let mut formatter = formatter.debug_tuple("Add");
                formatter.finish()
            }
            syn::BinOp::Sub(_v0) => {
                let mut formatter = formatter.debug_tuple("Sub");
                formatter.finish()
            }
            syn::BinOp::Mul(_v0) => {
                let mut formatter = formatter.debug_tuple("Mul");
                formatter.finish()
            }
            syn::BinOp::Div(_v0) => {
                let mut formatter = formatter.debug_tuple("Div");
                formatter.finish()
            }
            syn::BinOp::Rem(_v0) => {
                let mut formatter = formatter.debug_tuple("Rem");
                formatter.finish()
            }
            syn::BinOp::And(_v0) => {
                let mut formatter = formatter.debug_tuple("And");
                formatter.finish()
            }
            syn::BinOp::Or(_v0) => {
                let mut formatter = formatter.debug_tuple("Or");
                formatter.finish()
            }
            syn::BinOp::BitXor(_v0) => {
                let mut formatter = formatter.debug_tuple("BitXor");
                formatter.finish()
            }
            syn::BinOp::BitAnd(_v0) => {
                let mut formatter = formatter.debug_tuple("BitAnd");
                formatter.finish()
            }
            syn::BinOp::BitOr(_v0) => {
                let mut formatter = formatter.debug_tuple("BitOr");
                formatter.finish()
            }
            syn::BinOp::Shl(_v0) => {
                let mut formatter = formatter.debug_tuple("Shl");
                formatter.finish()
            }
            syn::BinOp::Shr(_v0) => {
                let mut formatter = formatter.debug_tuple("Shr");
                formatter.finish()
            }
            syn::BinOp::Eq(_v0) => {
                let mut formatter = formatter.debug_tuple("Eq");
                formatter.finish()
            }
            syn::BinOp::Lt(_v0) => {
                let mut formatter = formatter.debug_tuple("Lt");
                formatter.finish()
            }
            syn::BinOp::Le(_v0) => {
                let mut formatter = formatter.debug_tuple("Le");
                formatter.finish()
            }
            syn::BinOp::Ne(_v0) => {
                let mut formatter = formatter.debug_tuple("Ne");
                formatter.finish()
            }
            syn::BinOp::Ge(_v0) => {
                let mut formatter = formatter.debug_tuple("Ge");
                formatter.finish()
            }
            syn::BinOp::Gt(_v0) => {
                let mut formatter = formatter.debug_tuple("Gt");
                formatter.finish()
            }
            syn::BinOp::AddEq(_v0) => {
                let mut formatter = formatter.debug_tuple("AddEq");
                formatter.finish()
            }
            syn::BinOp::SubEq(_v0) => {
                let mut formatter = formatter.debug_tuple("SubEq");
                formatter.finish()
            }
            syn::BinOp::MulEq(_v0) => {
                let mut formatter = formatter.debug_tuple("MulEq");
                formatter.finish()
            }
            syn::BinOp::DivEq(_v0) => {
                let mut formatter = formatter.debug_tuple("DivEq");
                formatter.finish()
            }
            syn::BinOp::RemEq(_v0) => {
                let mut formatter = formatter.debug_tuple("RemEq");
                formatter.finish()
            }
            syn::BinOp::BitXorEq(_v0) => {
                let mut formatter = formatter.debug_tuple("BitXorEq");
                formatter.finish()
            }
            syn::BinOp::BitAndEq(_v0) => {
                let mut formatter = formatter.debug_tuple("BitAndEq");
                formatter.finish()
            }
            syn::BinOp::BitOrEq(_v0) => {
                let mut formatter = formatter.debug_tuple("BitOrEq");
                formatter.finish()
            }
            syn::BinOp::ShlEq(_v0) => {
                let mut formatter = formatter.debug_tuple("ShlEq");
                formatter.finish()
            }
            syn::BinOp::ShrEq(_v0) => {
                let mut formatter = formatter.debug_tuple("ShrEq");
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Binding> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Binding");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Block> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Block");
        formatter.field("stmts", Lite(&self.value.stmts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::BoundLifetimes> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("BoundLifetimes");
        formatter.field("lifetimes", Lite(&self.value.lifetimes));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ConstParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ConstParam");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("ty", Lite(&self.value.ty));
        if let Some(val) = &self.value.eq_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Eq);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("eq_token", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Expr);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Constraint> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Constraint");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Data> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Data::Struct(_v0) => {
                let mut formatter = formatter.debug_tuple("Struct");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Data::Enum(_v0) => {
                let mut formatter = formatter.debug_tuple("Enum");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Data::Union(_v0) => {
                let mut formatter = formatter.debug_tuple("Union");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::DataEnum> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("DataEnum");
        formatter.field("variants", Lite(&self.value.variants));
        formatter.finish()
    }
}
impl Debug for Lite<syn::DataStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("DataStruct");
        formatter.field("fields", Lite(&self.value.fields));
        if let Some(val) = &self.value.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::DataUnion> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("DataUnion");
        formatter.field("fields", Lite(&self.value.fields));
        formatter.finish()
    }
}
impl Debug for Lite<syn::DeriveInput> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("DeriveInput");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("data", Lite(&self.value.data));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Expr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Expr::Box(_v0) => {
                let mut formatter = formatter.debug_tuple("Box");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::InPlace(_v0) => {
                let mut formatter = formatter.debug_tuple("InPlace");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Array(_v0) => {
                let mut formatter = formatter.debug_tuple("Array");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Call(_v0) => {
                let mut formatter = formatter.debug_tuple("Call");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::MethodCall(_v0) => {
                let mut formatter = formatter.debug_tuple("MethodCall");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Tuple(_v0) => {
                let mut formatter = formatter.debug_tuple("Tuple");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Binary(_v0) => {
                let mut formatter = formatter.debug_tuple("Binary");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Unary(_v0) => {
                let mut formatter = formatter.debug_tuple("Unary");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Lit(_v0) => {
                let mut formatter = formatter.debug_tuple("Lit");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Cast(_v0) => {
                let mut formatter = formatter.debug_tuple("Cast");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Let(_v0) => {
                let mut formatter = formatter.debug_tuple("Let");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::If(_v0) => {
                let mut formatter = formatter.debug_tuple("If");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::While(_v0) => {
                let mut formatter = formatter.debug_tuple("While");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::ForLoop(_v0) => {
                let mut formatter = formatter.debug_tuple("ForLoop");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Loop(_v0) => {
                let mut formatter = formatter.debug_tuple("Loop");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Match(_v0) => {
                let mut formatter = formatter.debug_tuple("Match");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Closure(_v0) => {
                let mut formatter = formatter.debug_tuple("Closure");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Unsafe(_v0) => {
                let mut formatter = formatter.debug_tuple("Unsafe");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Block(_v0) => {
                let mut formatter = formatter.debug_tuple("Block");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Assign(_v0) => {
                let mut formatter = formatter.debug_tuple("Assign");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::AssignOp(_v0) => {
                let mut formatter = formatter.debug_tuple("AssignOp");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Field(_v0) => {
                let mut formatter = formatter.debug_tuple("Field");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Index(_v0) => {
                let mut formatter = formatter.debug_tuple("Index");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Range(_v0) => {
                let mut formatter = formatter.debug_tuple("Range");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Path(_v0) => {
                let mut formatter = formatter.debug_tuple("Path");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Reference(_v0) => {
                let mut formatter = formatter.debug_tuple("Reference");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Break(_v0) => {
                let mut formatter = formatter.debug_tuple("Break");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Continue(_v0) => {
                let mut formatter = formatter.debug_tuple("Continue");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Return(_v0) => {
                let mut formatter = formatter.debug_tuple("Return");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Macro(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Struct(_v0) => {
                let mut formatter = formatter.debug_tuple("Struct");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Repeat(_v0) => {
                let mut formatter = formatter.debug_tuple("Repeat");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Paren(_v0) => {
                let mut formatter = formatter.debug_tuple("Paren");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Group(_v0) => {
                let mut formatter = formatter.debug_tuple("Group");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Try(_v0) => {
                let mut formatter = formatter.debug_tuple("Try");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Async(_v0) => {
                let mut formatter = formatter.debug_tuple("Async");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::TryBlock(_v0) => {
                let mut formatter = formatter.debug_tuple("TryBlock");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Yield(_v0) => {
                let mut formatter = formatter.debug_tuple("Yield");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Expr::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::ExprArray> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprArray");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("elems", Lite(&self.value.elems));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprAssign> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprAssign");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("left", Lite(&self.value.left));
        formatter.field("right", Lite(&self.value.right));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprAssignOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprAssignOp");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("left", Lite(&self.value.left));
        formatter.field("op", Lite(&self.value.op));
        formatter.field("right", Lite(&self.value.right));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprAsync> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprAsync");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.capture {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Move);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("capture", Print::ref_cast(val));
        }
        formatter.field("block", Lite(&self.value.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBinary> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprBinary");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("left", Lite(&self.value.left));
        formatter.field("op", Lite(&self.value.op));
        formatter.field("right", Lite(&self.value.right));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBlock> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprBlock");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("block", Lite(&self.value.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBox> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprBox");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBreak> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprBreak");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.expr {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("expr", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprCall> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprCall");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("func", Lite(&self.value.func));
        formatter.field("args", Lite(&self.value.args));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprCast> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprCast");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprClosure> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprClosure");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.asyncness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Async);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("asyncness", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.movability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Static);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("movability", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.capture {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Move);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("capture", Print::ref_cast(val));
        }
        formatter.field("inputs", Lite(&self.value.inputs));
        formatter.field("output", Lite(&self.value.output));
        formatter.field("body", Lite(&self.value.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprContinue> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprContinue");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprField> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprField");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("base", Lite(&self.value.base));
        formatter.field("member", Lite(&self.value.member));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprForLoop> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprForLoop");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&self.value.pat));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.field("body", Lite(&self.value.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprGroup");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprIf> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprIf");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("cond", Lite(&self.value.cond));
        formatter.field("then_branch", Lite(&self.value.then_branch));
        if let Some(val) = &self.value.else_branch {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Else, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("else_branch", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprInPlace> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprInPlace");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("place", Lite(&self.value.place));
        formatter.field("value", Lite(&self.value.value));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprIndex> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprIndex");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.field("index", Lite(&self.value.index));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLet> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprLet");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("pats", Lite(&self.value.pats));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprLit");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("lit", Lite(&self.value.lit));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLoop> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprLoop");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("body", Lite(&self.value.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprMacro");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("mac", Lite(&self.value.mac));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMatch> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprMatch");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.field("arms", Lite(&self.value.arms));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMethodCall> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprMethodCall");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("receiver", Lite(&self.value.receiver));
        formatter.field("method", Lite(&self.value.method));
        if let Some(val) = &self.value.turbofish {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::MethodTurbofish);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("turbofish", Print::ref_cast(val));
        }
        formatter.field("args", Lite(&self.value.args));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprParen> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprParen");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprPath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprPath");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&self.value.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprRange> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprRange");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.from {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("from", Print::ref_cast(val));
        }
        formatter.field("limits", Lite(&self.value.limits));
        if let Some(val) = &self.value.to {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("to", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprReference");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprRepeat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprRepeat");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.field("len", Lite(&self.value.len));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprReturn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprReturn");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.expr {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("expr", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprStruct");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("path", Lite(&self.value.path));
        formatter.field("fields", Lite(&self.value.fields));
        if let Some(val) = &self.value.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.rest {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("rest", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprTry> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprTry");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprTryBlock> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprTryBlock");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("block", Lite(&self.value.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprTuple");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("elems", Lite(&self.value.elems));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprType");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprUnary> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprUnary");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("op", Lite(&self.value.op));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprUnsafe> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprUnsafe");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("block", Lite(&self.value.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprVerbatim");
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprWhile> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprWhile");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("cond", Lite(&self.value.cond));
        formatter.field("body", Lite(&self.value.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprYield> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ExprYield");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.expr {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("expr", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Field> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Field");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.ident {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(proc_macro2::Ident);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("ident", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldPat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("FieldPat");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("member", Lite(&self.value.member));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&self.value.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldValue> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("FieldValue");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("member", Lite(&self.value.member));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Fields> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Fields::Named(_v0) => {
                let mut formatter = formatter.debug_tuple("Named");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Fields::Unnamed(_v0) => {
                let mut formatter = formatter.debug_tuple("Unnamed");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Fields::Unit => formatter.write_str("Unit"),
        }
    }
}
impl Debug for Lite<syn::FieldsNamed> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("FieldsNamed");
        formatter.field("named", Lite(&self.value.named));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldsUnnamed> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("FieldsUnnamed");
        formatter.field("unnamed", Lite(&self.value.unnamed));
        formatter.finish()
    }
}
impl Debug for Lite<syn::File> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("File");
        if let Some(val) = &self.value.shebang {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(String);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("shebang", Print::ref_cast(val));
        }
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("items", Lite(&self.value.items));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FnArg> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::FnArg::SelfRef(_v0) => {
                let mut formatter = formatter.debug_tuple("SelfRef");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::FnArg::SelfValue(_v0) => {
                let mut formatter = formatter.debug_tuple("SelfValue");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::FnArg::Captured(_v0) => {
                let mut formatter = formatter.debug_tuple("Captured");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::FnArg::Inferred(_v0) => {
                let mut formatter = formatter.debug_tuple("Inferred");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::FnArg::Ignored(_v0) => {
                let mut formatter = formatter.debug_tuple("Ignored");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::FnDecl> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("FnDecl");
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("inputs", Lite(&self.value.inputs));
        if let Some(val) = &self.value.variadic {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot3);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("variadic", Print::ref_cast(val));
        }
        formatter.field("output", Lite(&self.value.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItem> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::ForeignItem::Fn(_v0) => {
                let mut formatter = formatter.debug_tuple("Fn");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ForeignItem::Static(_v0) => {
                let mut formatter = formatter.debug_tuple("Static");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ForeignItem::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ForeignItem::Macro(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ForeignItem::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::ForeignItemFn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ForeignItemFn");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("decl", Lite(&self.value.decl));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ForeignItemMacro");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("mac", Lite(&self.value.mac));
        if let Some(val) = &self.value.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItemStatic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ForeignItemStatic");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ForeignItemType");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItemVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ForeignItemVerbatim");
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::GenericArgument> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::GenericArgument::Lifetime(_v0) => {
                let mut formatter = formatter.debug_tuple("Lifetime");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::GenericArgument::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::GenericArgument::Binding(_v0) => {
                let mut formatter = formatter.debug_tuple("Binding");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::GenericArgument::Constraint(_v0) => {
                let mut formatter = formatter.debug_tuple("Constraint");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::GenericArgument::Const(_v0) => {
                let mut formatter = formatter.debug_tuple("Const");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::GenericMethodArgument> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::GenericMethodArgument::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::GenericMethodArgument::Const(_v0) => {
                let mut formatter = formatter.debug_tuple("Const");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::GenericParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::GenericParam::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::GenericParam::Lifetime(_v0) => {
                let mut formatter = formatter.debug_tuple("Lifetime");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::GenericParam::Const(_v0) => {
                let mut formatter = formatter.debug_tuple("Const");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Generics> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Generics");
        if let Some(val) = &self.value.lt_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Lt);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("lt_token", Print::ref_cast(val));
        }
        formatter.field("params", Lite(&self.value.params));
        if let Some(val) = &self.value.gt_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Gt);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("gt_token", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.where_clause {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::WhereClause);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("where_clause", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItem> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::ImplItem::Const(_v0) => {
                let mut formatter = formatter.debug_tuple("Const");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ImplItem::Method(_v0) => {
                let mut formatter = formatter.debug_tuple("Method");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ImplItem::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ImplItem::Existential(_v0) => {
                let mut formatter = formatter.debug_tuple("Existential");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ImplItem::Macro(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::ImplItem::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::ImplItemConst> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ImplItemConst");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemExistential> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ImplItemExistential");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ImplItemMacro");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("mac", Lite(&self.value.mac));
        if let Some(val) = &self.value.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemMethod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ImplItemMethod");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        formatter.field("sig", Lite(&self.value.sig));
        formatter.field("block", Lite(&self.value.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ImplItemType");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ImplItemVerbatim");
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Index> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Index");
        formatter.field("index", Lite(&self.value.index));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Item> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Item::ExternCrate(_v0) => {
                let mut formatter = formatter.debug_tuple("ExternCrate");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Use(_v0) => {
                let mut formatter = formatter.debug_tuple("Use");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Static(_v0) => {
                let mut formatter = formatter.debug_tuple("Static");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Const(_v0) => {
                let mut formatter = formatter.debug_tuple("Const");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Fn(_v0) => {
                let mut formatter = formatter.debug_tuple("Fn");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Mod(_v0) => {
                let mut formatter = formatter.debug_tuple("Mod");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::ForeignMod(_v0) => {
                let mut formatter = formatter.debug_tuple("ForeignMod");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Existential(_v0) => {
                let mut formatter = formatter.debug_tuple("Existential");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Struct(_v0) => {
                let mut formatter = formatter.debug_tuple("Struct");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Enum(_v0) => {
                let mut formatter = formatter.debug_tuple("Enum");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Union(_v0) => {
                let mut formatter = formatter.debug_tuple("Union");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Trait(_v0) => {
                let mut formatter = formatter.debug_tuple("Trait");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::TraitAlias(_v0) => {
                let mut formatter = formatter.debug_tuple("TraitAlias");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Impl(_v0) => {
                let mut formatter = formatter.debug_tuple("Impl");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Macro(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Macro2(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro2");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Item::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::ItemConst> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemConst");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemEnum> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemEnum");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("variants", Lite(&self.value.variants));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemExistential> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemExistential");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemExternCrate> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemExternCrate");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        if let Some(val) = &self.value.rename {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::As, proc_macro2::Ident));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("rename", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemFn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemFn");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.constness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Const);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("constness", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.asyncness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Async);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("asyncness", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.abi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Abi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("abi", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("decl", Lite(&self.value.decl));
        formatter.field("block", Lite(&self.value.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemForeignMod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemForeignMod");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("abi", Lite(&self.value.abi));
        formatter.field("items", Lite(&self.value.items));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemImpl> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemImpl");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        formatter.field("generics", Lite(&self.value.generics));
        if let Some(val) = &self.value.trait_ {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((Option<syn::token::Bang>, syn::Path, syn::token::For));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(
                        &(
                            {
                                #[derive(RefCast)]
                                #[repr(transparent)]
                                struct Print(Option<syn::token::Bang>);
                                impl Debug for Print {
                                    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                                        match &self.0 {
                                            Some(_val) => {
                                                formatter.write_str("Some")?;
                                                Ok(())
                                            }
                                            None => formatter.write_str("None"),
                                        }
                                    }
                                }
                                Print::ref_cast(&_val.0)
                            },
                            Lite(&_val.1),
                        ),
                        formatter,
                    )?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("trait_", Print::ref_cast(val));
        }
        formatter.field("self_ty", Lite(&self.value.self_ty));
        formatter.field("items", Lite(&self.value.items));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemMacro");
        formatter.field("attrs", Lite(&self.value.attrs));
        if let Some(val) = &self.value.ident {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(proc_macro2::Ident);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("ident", Print::ref_cast(val));
        }
        formatter.field("mac", Lite(&self.value.mac));
        if let Some(val) = &self.value.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemMacro2> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemMacro2");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("args", Lite(&self.value.args));
        formatter.field("body", Lite(&self.value.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemMod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemMod");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        if let Some(val) = &self.value.content {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Brace, Vec<syn::Item>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("content", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.semi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemStatic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemStatic");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemStruct");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("fields", Lite(&self.value.fields));
        if let Some(val) = &self.value.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemTrait> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemTrait");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.auto_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Auto);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("auto_token", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("supertraits", Lite(&self.value.supertraits));
        formatter.field("items", Lite(&self.value.items));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemTraitAlias> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemTraitAlias");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemType");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("ty", Lite(&self.value.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemUnion> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemUnion");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        formatter.field("fields", Lite(&self.value.fields));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemUse> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemUse");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("vis", Lite(&self.value.vis));
        if let Some(val) = &self.value.leading_colon {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_colon", Print::ref_cast(val));
        }
        formatter.field("tree", Lite(&self.value.tree));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ItemVerbatim");
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Label> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Label");
        formatter.field("name", Lite(&self.value.name));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Lifetime> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Lifetime");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.finish()
    }
}
impl Debug for Lite<syn::LifetimeDef> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("LifetimeDef");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("lifetime", Lite(&self.value.lifetime));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Lit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Lit::Str(_v0) => {
                let mut formatter = formatter.debug_tuple("Str");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Lit::ByteStr(_v0) => {
                let mut formatter = formatter.debug_tuple("ByteStr");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Lit::Byte(_v0) => {
                let mut formatter = formatter.debug_tuple("Byte");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Lit::Char(_v0) => {
                let mut formatter = formatter.debug_tuple("Char");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Lit::Int(_v0) => {
                let mut formatter = formatter.debug_tuple("Int");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Lit::Float(_v0) => {
                let mut formatter = formatter.debug_tuple("Float");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Lit::Bool(_v0) => {
                let mut formatter = formatter.debug_tuple("Bool");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Lit::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::LitBool> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("LitBool");
        formatter.field("value", Lite(&self.value.value));
        formatter.finish()
    }
}
impl Debug for Lite<syn::LitByte> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:?}", self.value())
    }
}
impl Debug for Lite<syn::LitByteStr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:?}", self.value())
    }
}
impl Debug for Lite<syn::LitChar> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:?}", self.value())
    }
}
impl Debug for Lite<syn::LitFloat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:?}", self.value())
    }
}
impl Debug for Lite<syn::LitInt> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:?}", self.value())
    }
}
impl Debug for Lite<syn::LitStr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:?}", self.value())
    }
}
impl Debug for Lite<syn::LitVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("LitVerbatim");
        formatter.field("token", Lite(&self.value.token));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Local> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Local");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("pats", Lite(&self.value.pats));
        if let Some(val) = &self.value.ty {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Colon, Box<syn::Type>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("ty", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.init {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("init", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Macro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Macro");
        formatter.field("path", Lite(&self.value.path));
        formatter.field("delimiter", Lite(&self.value.delimiter));
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::MacroDelimiter> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::MacroDelimiter::Paren(_v0) => {
                let mut formatter = formatter.debug_tuple("Paren");
                formatter.finish()
            }
            syn::MacroDelimiter::Brace(_v0) => {
                let mut formatter = formatter.debug_tuple("Brace");
                formatter.finish()
            }
            syn::MacroDelimiter::Bracket(_v0) => {
                let mut formatter = formatter.debug_tuple("Bracket");
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Member> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Member::Named(_v0) => {
                let mut formatter = formatter.debug_tuple("Named");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Member::Unnamed(_v0) => {
                let mut formatter = formatter.debug_tuple("Unnamed");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Meta> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Meta::Word(_v0) => {
                let mut formatter = formatter.debug_tuple("Word");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Meta::List(_v0) => {
                let mut formatter = formatter.debug_tuple("List");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Meta::NameValue(_v0) => {
                let mut formatter = formatter.debug_tuple("NameValue");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::MetaList> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("MetaList");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("nested", Lite(&self.value.nested));
        formatter.finish()
    }
}
impl Debug for Lite<syn::MetaNameValue> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("MetaNameValue");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("lit", Lite(&self.value.lit));
        formatter.finish()
    }
}
impl Debug for Lite<syn::MethodSig> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("MethodSig");
        if let Some(val) = &self.value.constness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Const);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("constness", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.asyncness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Async);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("asyncness", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.abi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Abi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("abi", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("decl", Lite(&self.value.decl));
        formatter.finish()
    }
}
impl Debug for Lite<syn::MethodTurbofish> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("MethodTurbofish");
        formatter.field("args", Lite(&self.value.args));
        formatter.finish()
    }
}
impl Debug for Lite<syn::NestedMeta> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::NestedMeta::Meta(_v0) => {
                let mut formatter = formatter.debug_tuple("Meta");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::NestedMeta::Literal(_v0) => {
                let mut formatter = formatter.debug_tuple("Literal");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::ParenthesizedGenericArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("ParenthesizedGenericArguments");
        formatter.field("inputs", Lite(&self.value.inputs));
        formatter.field("output", Lite(&self.value.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Pat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Pat::Wild(_v0) => {
                let mut formatter = formatter.debug_tuple("Wild");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Ident(_v0) => {
                let mut formatter = formatter.debug_tuple("Ident");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Struct(_v0) => {
                let mut formatter = formatter.debug_tuple("Struct");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::TupleStruct(_v0) => {
                let mut formatter = formatter.debug_tuple("TupleStruct");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Path(_v0) => {
                let mut formatter = formatter.debug_tuple("Path");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Tuple(_v0) => {
                let mut formatter = formatter.debug_tuple("Tuple");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Box(_v0) => {
                let mut formatter = formatter.debug_tuple("Box");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Ref(_v0) => {
                let mut formatter = formatter.debug_tuple("Ref");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Lit(_v0) => {
                let mut formatter = formatter.debug_tuple("Lit");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Range(_v0) => {
                let mut formatter = formatter.debug_tuple("Range");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Slice(_v0) => {
                let mut formatter = formatter.debug_tuple("Slice");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Macro(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Pat::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::PatBox> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatBox");
        formatter.field("pat", Lite(&self.value.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatIdent> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatIdent");
        if let Some(val) = &self.value.by_ref {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Ref);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("by_ref", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&self.value.ident));
        if let Some(val) = &self.value.subpat {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::At, Box<syn::Pat>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("subpat", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatLit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatLit");
        formatter.field("expr", Lite(&self.value.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatMacro");
        formatter.field("mac", Lite(&self.value.mac));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatPath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatPath");
        if let Some(val) = &self.value.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&self.value.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatRange> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatRange");
        formatter.field("lo", Lite(&self.value.lo));
        formatter.field("limits", Lite(&self.value.limits));
        formatter.field("hi", Lite(&self.value.hi));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatRef> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatRef");
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&self.value.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatSlice> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatSlice");
        formatter.field("front", Lite(&self.value.front));
        if let Some(val) = &self.value.middle {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Pat>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("middle", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.comma_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Comma);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("comma_token", Print::ref_cast(val));
        }
        formatter.field("back", Lite(&self.value.back));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatStruct");
        formatter.field("path", Lite(&self.value.path));
        formatter.field("fields", Lite(&self.value.fields));
        if let Some(val) = &self.value.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatTuple");
        formatter.field("front", Lite(&self.value.front));
        if let Some(val) = &self.value.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.comma_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Comma);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("comma_token", Print::ref_cast(val));
        }
        formatter.field("back", Lite(&self.value.back));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatTupleStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatTupleStruct");
        formatter.field("path", Lite(&self.value.path));
        formatter.field("pat", Lite(&self.value.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatVerbatim");
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatWild> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PatWild");
        formatter.finish()
    }
}
impl Debug for Lite<syn::Path> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Path");
        if let Some(val) = &self.value.leading_colon {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_colon", Print::ref_cast(val));
        }
        formatter.field("segments", Lite(&self.value.segments));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PathArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::PathArguments::None => formatter.write_str("None"),
            syn::PathArguments::AngleBracketed(_v0) => {
                let mut formatter = formatter.debug_tuple("AngleBracketed");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::PathArguments::Parenthesized(_v0) => {
                let mut formatter = formatter.debug_tuple("Parenthesized");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::PathSegment> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PathSegment");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("arguments", Lite(&self.value.arguments));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateEq> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PredicateEq");
        formatter.field("lhs_ty", Lite(&self.value.lhs_ty));
        formatter.field("rhs_ty", Lite(&self.value.rhs_ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateLifetime> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PredicateLifetime");
        formatter.field("lifetime", Lite(&self.value.lifetime));
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("PredicateType");
        if let Some(val) = &self.value.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        formatter.field("bounded_ty", Lite(&self.value.bounded_ty));
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::QSelf> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("QSelf");
        formatter.field("ty", Lite(&self.value.ty));
        formatter.field("position", Lite(&self.value.position));
        if let Some(val) = &self.value.as_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::As);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("as_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::RangeLimits> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::RangeLimits::HalfOpen(_v0) => {
                let mut formatter = formatter.debug_tuple("HalfOpen");
                formatter.finish()
            }
            syn::RangeLimits::Closed(_v0) => {
                let mut formatter = formatter.debug_tuple("Closed");
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::ReturnType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::ReturnType::Default => formatter.write_str("Default"),
            syn::ReturnType::Type(_v0, _v1) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v1));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Stmt> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Stmt::Local(_v0) => {
                let mut formatter = formatter.debug_tuple("Local");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Stmt::Item(_v0) => {
                let mut formatter = formatter.debug_tuple("Item");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Stmt::Expr(_v0) => {
                let mut formatter = formatter.debug_tuple("Expr");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Stmt::Semi(_v0, _v1) => {
                let mut formatter = formatter.debug_tuple("Semi");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::TraitBound> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TraitBound");
        if let Some(val) = &self.value.paren_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Paren);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("paren_token", Print::ref_cast(val));
        }
        formatter.field("modifier", Lite(&self.value.modifier));
        if let Some(val) = &self.value.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&self.value.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitBoundModifier> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::TraitBoundModifier::None => formatter.write_str("None"),
            syn::TraitBoundModifier::Maybe(_v0) => {
                let mut formatter = formatter.debug_tuple("Maybe");
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::TraitItem> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::TraitItem::Const(_v0) => {
                let mut formatter = formatter.debug_tuple("Const");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::TraitItem::Method(_v0) => {
                let mut formatter = formatter.debug_tuple("Method");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::TraitItem::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::TraitItem::Macro(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::TraitItem::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::TraitItemConst> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TraitItemConst");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("ty", Lite(&self.value.ty));
        if let Some(val) = &self.value.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, syn::Expr));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TraitItemMacro");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("mac", Lite(&self.value.mac));
        if let Some(val) = &self.value.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitItemMethod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TraitItemMethod");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("sig", Lite(&self.value.sig));
        if let Some(val) = &self.value.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Block);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TraitItemType");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("generics", Lite(&self.value.generics));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("bounds", Lite(&self.value.bounds));
        if let Some(val) = &self.value.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, syn::Type));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitItemVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TraitItemVerbatim");
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Type> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Type::Slice(_v0) => {
                let mut formatter = formatter.debug_tuple("Slice");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Array(_v0) => {
                let mut formatter = formatter.debug_tuple("Array");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Ptr(_v0) => {
                let mut formatter = formatter.debug_tuple("Ptr");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Reference(_v0) => {
                let mut formatter = formatter.debug_tuple("Reference");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::BareFn(_v0) => {
                let mut formatter = formatter.debug_tuple("BareFn");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Never(_v0) => {
                let mut formatter = formatter.debug_tuple("Never");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Tuple(_v0) => {
                let mut formatter = formatter.debug_tuple("Tuple");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Path(_v0) => {
                let mut formatter = formatter.debug_tuple("Path");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::TraitObject(_v0) => {
                let mut formatter = formatter.debug_tuple("TraitObject");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::ImplTrait(_v0) => {
                let mut formatter = formatter.debug_tuple("ImplTrait");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Paren(_v0) => {
                let mut formatter = formatter.debug_tuple("Paren");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Group(_v0) => {
                let mut formatter = formatter.debug_tuple("Group");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Infer(_v0) => {
                let mut formatter = formatter.debug_tuple("Infer");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Macro(_v0) => {
                let mut formatter = formatter.debug_tuple("Macro");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Type::Verbatim(_v0) => {
                let mut formatter = formatter.debug_tuple("Verbatim");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::TypeArray> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeArray");
        formatter.field("elem", Lite(&self.value.elem));
        formatter.field("len", Lite(&self.value.len));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeBareFn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeBareFn");
        if let Some(val) = &self.value.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.abi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Abi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("abi", Print::ref_cast(val));
        }
        formatter.field("inputs", Lite(&self.value.inputs));
        if let Some(val) = &self.value.variadic {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot3);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("variadic", Print::ref_cast(val));
        }
        formatter.field("output", Lite(&self.value.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeGroup");
        formatter.field("elem", Lite(&self.value.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeImplTrait> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeImplTrait");
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeInfer> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeInfer");
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeMacro");
        formatter.field("mac", Lite(&self.value.mac));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeNever> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeNever");
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeParam");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("ident", Lite(&self.value.ident));
        if let Some(val) = &self.value.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("bounds", Lite(&self.value.bounds));
        if let Some(val) = &self.value.eq_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Eq);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("eq_token", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Type);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeParamBound> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::TypeParamBound::Trait(_v0) => {
                let mut formatter = formatter.debug_tuple("Trait");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::TypeParamBound::Lifetime(_v0) => {
                let mut formatter = formatter.debug_tuple("Lifetime");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::TypeParen> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeParen");
        formatter.field("elem", Lite(&self.value.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypePath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypePath");
        if let Some(val) = &self.value.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&self.value.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypePtr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypePtr");
        if let Some(val) = &self.value.const_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Const);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("const_token", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("elem", Lite(&self.value.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeReference");
        if let Some(val) = &self.value.lifetime {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetime", Print::ref_cast(val));
        }
        if let Some(val) = &self.value.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("elem", Lite(&self.value.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeSlice> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeSlice");
        formatter.field("elem", Lite(&self.value.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeTraitObject> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeTraitObject");
        if let Some(val) = &self.value.dyn_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dyn);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dyn_token", Print::ref_cast(val));
        }
        formatter.field("bounds", Lite(&self.value.bounds));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeTuple");
        formatter.field("elems", Lite(&self.value.elems));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeVerbatim> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("TypeVerbatim");
        formatter.field("tts", Lite(&self.value.tts));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UnOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::UnOp::Deref(_v0) => {
                let mut formatter = formatter.debug_tuple("Deref");
                formatter.finish()
            }
            syn::UnOp::Not(_v0) => {
                let mut formatter = formatter.debug_tuple("Not");
                formatter.finish()
            }
            syn::UnOp::Neg(_v0) => {
                let mut formatter = formatter.debug_tuple("Neg");
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::UseGlob> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("UseGlob");
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("UseGroup");
        formatter.field("items", Lite(&self.value.items));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseName> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("UseName");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UsePath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("UsePath");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("tree", Lite(&self.value.tree));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseRename> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("UseRename");
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("rename", Lite(&self.value.rename));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseTree> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::UseTree::Path(_v0) => {
                let mut formatter = formatter.debug_tuple("Path");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::UseTree::Name(_v0) => {
                let mut formatter = formatter.debug_tuple("Name");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::UseTree::Rename(_v0) => {
                let mut formatter = formatter.debug_tuple("Rename");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::UseTree::Glob(_v0) => {
                let mut formatter = formatter.debug_tuple("Glob");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::UseTree::Group(_v0) => {
                let mut formatter = formatter.debug_tuple("Group");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Variant> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("Variant");
        formatter.field("attrs", Lite(&self.value.attrs));
        formatter.field("ident", Lite(&self.value.ident));
        formatter.field("fields", Lite(&self.value.fields));
        if let Some(val) = &self.value.discriminant {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, syn::Expr));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("discriminant", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::VisCrate> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("VisCrate");
        formatter.finish()
    }
}
impl Debug for Lite<syn::VisPublic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("VisPublic");
        formatter.finish()
    }
}
impl Debug for Lite<syn::VisRestricted> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("VisRestricted");
        if let Some(val) = &self.value.in_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::In);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("in_token", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&self.value.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Visibility> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::Visibility::Public(_v0) => {
                let mut formatter = formatter.debug_tuple("Public");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Visibility::Crate(_v0) => {
                let mut formatter = formatter.debug_tuple("Crate");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Visibility::Restricted(_v0) => {
                let mut formatter = formatter.debug_tuple("Restricted");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::Visibility::Inherited => formatter.write_str("Inherited"),
        }
    }
}
impl Debug for Lite<syn::WhereClause> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = formatter.debug_struct("WhereClause");
        formatter.field("predicates", Lite(&self.value.predicates));
        formatter.finish()
    }
}
impl Debug for Lite<syn::WherePredicate> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            syn::WherePredicate::Type(_v0) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::WherePredicate::Lifetime(_v0) => {
                let mut formatter = formatter.debug_tuple("Lifetime");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
            syn::WherePredicate::Eq(_v0) => {
                let mut formatter = formatter.debug_tuple("Eq");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
